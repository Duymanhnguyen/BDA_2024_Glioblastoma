---
title: "BDA_2024_MetaAnalysis_Glioblastoma"
author: "Duy Nguyen"
date: "2024-06-25"
output: 
  pdf_document:
    latex_engine: xelatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE, 
                      warning = FALSE)
```


## Research Flow of Meta-Analysis of Transcriptomics Profile in Glioblastoma

*Step 1:* Project set up with necessary packages

*Step 2:* Search for dataset in Gemma using search terms 

*Step 3*: Extract annotations for every class in the datasets, including:

1. Organism part 

2. Cell type

3. Developmental stage 

4. Treatment

5. Disease

6. Disease model

7. Genotype

8. Strain

9. Biological sex

(These annotations would be helpful in dataset selection based on inclusion/exclusion
criteria regarding these classes)

*Step 4:* Extract annotations for experimental design in the datasets, including:

1. Factor categories 

2. Experimental factors 

3. Baseline factors 

(These annotations would be helpful in dataset selection as they show which variables
were actually manipulated as part of the experiment, especially for datasets in large
studies containing multiple experiments)

*Step 5:* Extract statistical contrasts of differential analysis in the datasets

(These statistical contrasts allow us to check if the differential analyses are:

- Subsetted by brain region 

- Included unwanted subjects

- Set up in an appropriate manner with the reference group

Based on the statistical contrasts, we might need to re-run the differential analysis)

*Step 6:* Assess gene expression range 

(Some datasets, especially Agilent microarray datasets, were normalized incorrectly,
which may require re-normalization)


### 1) Project Set Up

```{r setdw, eval = FALSE, echo = FALSE}
# Set working directory 
setdw("/Users/manhduynguyen/BDA_2024_Glioblastoma")
```


```{r renv, eval = FALSE, echo = FALSE}
# Initiate the project with renv
renv::init()

# Save to lockfile
renv::snapshot()
```


```{r install_pack, eval = FALSE, echo = FALSE}
# Download packages
if(!requireNamespace("devtools", quietly = T)){
  install.packages("devtools")
}
devtools:: install_github("PavlidisLab/gemma.R", force = T)

if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install("multtest")                                 
BiocManager::install("clusterProfiler")
# Mus musculus (Mouse gene annotation database)
# Other databases include:
# 1. Rattus norvegicus (Rat) - org.Rn.eg.db
# 2. Mus musculus (Mouse) - org.Mm.eg.db
BiocManager::install("org.Hs.eg.db")
BiocManager::install("ReactomePA")  
BiocManager::install("fgsea")
BiocManager::install("pathview")

install.packages("plyr")
install.packages("dplyr")
install.packages("stringr")
install.packages("metafor")
install.packages("tidyverse")
install.packages("writexl")
install.packages("pheatmap")
install.packages("RColorBrewer")
install.packages("viridis")
install.packages("rentrez")
```


```{r load_pack}
# Load packages
library("gemma.R")
library("plyr")
library("stringr")
library("metafor")
library("tidyverse")
library("writexl")
library("pheatmap")
library("RColorBrewer")
library("viridis")
library("multtest")
library("rentrez")
library("clusterProfiler")
library("org.Hs.eg.db")
library("ReactomePA")
library("fgsea")
library("pathview")

# Check loaded packages 
(.packages())
```


### 2) Gemma Dataset Search

- Datasets in Gemma are annotated using structured terms of ontologies. Many of
the ontological terms are hierarchical.

- **`Ontologies`**: a set of concepts and categories in a subject area or domain 
that shows their properties and the relations between them.

- Within an ontological hierarchy, the broader, umbrella term is called the 
*"parent"* while the term representing the more specific subset is called the 
*"child"*. When requesting Gemma records with particular annotation, a parent 
term can often pull up all records with the child terms.


```{r onto_anno, cache = TRUE}
# Search for ontological annotations of "glioblastoma"
Gbm_onto_annotation <- search_annotations("glioblastom*")

# Count usage of ontological terms and filter terms that are used in Gemma
Gbm_onto_annotation_in_Gemma <- Gbm_onto_annotation %>%
  # Add new column "counts" in which the function is being applied to every
  # single value.URI from gbm_annotation
  mutate(counts = sapply(value.URI, function(uri){
    # This function retrieves "totalElements" attribute from the datasets 
    # associated with given input URI
    # The "totalElements" represent the total number of records
    attributes(get_datasets(uris = uri))$totalElements
  })) %>%
  # Filter to keep URI with at least 1 records
  filter(counts > 0)

# Check child terms for "glioblastoma"
get_child_terms("http://purl.obolibrary.org/obo/MONDO_0018177")
```


```{r search_data, cache = TRUE}
# Search dataset using search terms
Gbm_datasets_searchterm <- get_datasets(query = "glioblastom* OR 
                                                gbm OR gb OR gsc OR btic OR
                                                \"glioblastoma multiforme\"
                                                \"grade IV astrocytic tumor\" OR 
                                                \"grade IV astrocytoma\" OR 
                                                \"WHO grade IV glioma\" OR 
                                                \"glioblastoma stem cells\" OR
                                                \"self-renewing glioblastoma stem cells\" OR
                                                \"brain tumor initiating cells\" " ,
                                        # Focus on human datasets
                                        taxa = c("human")) %>%
  # Get full set of results
  get_all_pages()

# Check if abbreviations of "gbm" and "gb affect the search
Gbm_datasets_searchterm_noabbre <- get_datasets(query = "glioblastom* OR 
                                                \"glioblastoma multiforme\"
                                                \"grade IV astrocytic tumor\" OR 
                                                \"grade IV astrocytoma\" OR 
                                                \"WHO grade IV glioma\" OR
                                                \"glioblastoma stem cells\" OR
                                                \"self-renewing glioblastoma stem cells\" OR
                                                \"brain tumor initiating cells\" ",
                                        # Focus on human datasets
                                        taxa = c("human")) %>%
  # Get full set of results
  get_all_pages()

# Search dataset using parent term on ontological hierarchy
Gbm_datasets_uris <- get_datasets(uris = "http://purl.obolibrary.org/obo/MONDO_0018177",
                                  # Focus on human datasets
                                  taxa = c("human")) %>%
  # Get full set of results
  get_all_pages()

 
# Check the number of datasets in all dataframes
nrow(Gbm_datasets_searchterm)
nrow(Gbm_datasets_searchterm_noabbre)
nrow(Gbm_datasets_uris)

# Check if the datasets are duplicated in both methods of searching
Gbm_datasets_check <- Gbm_datasets_searchterm %>%
  mutate(available_in_both_dataframes = ifelse(experiment.shortName %in% 
                                               Gbm_datasets_uris$experiment.shortName, 
                                               TRUE, FALSE))

# Check the number of datasets
nrow(Gbm_datasets_check)

# Check the quality of the datasets
# (FALSE - data are of good quality)
table(Gbm_datasets_check$experiment.troubled)

# Check if raw data were available 
# (1 - raw data available | -1 - raw data not available)
table(Gbm_datasets_check$experiment.rawData)

# Filter for datasets with good quality and raw data available
Gbm_datasets_filtered <- Gbm_datasets_check %>%
  filter(experiment.troubled == FALSE & experiment.rawData == 1)

# Check the filtered datasets
str(Gbm_datasets_filtered)
```


#### 3) Extraction of Annotations for Each Class in Each Dataset

```{r func_extract_anno}
# Create a function to extract annotations
ExtractAnnotations <- function(dataset_shortname, annotation_class_name){
  # Extract annotations for the dataset experiment.shortNameentified by dataset_shortname
  exp_anno <- get_dataset_annotations(dataset = dataset_shortname)
  
  # Check if there are any annotations of the specified annotation_class_name
  if(any(exp_anno$class.name == annotation_class_name)){
    # If yes, return the term names associated with the specified annotation_class_name
    return(exp_anno$term.name[exp_anno$class.name == annotation_class_name])
  } else {
    # If no, return NA
    return(NA)
  }
}
```


```{r run_extract_anno, cache = TRUE}
# Function use 

# Extract annotation for organism part
Gbm_annotations_organism_part <- sapply(Gbm_datasets_filtered$experiment.shortName,
                                        ExtractAnnotations,
                                        annotation_class_name = "organism part") %>%
  # Transform into a dataframe
  enframe(name = "experiment.shortName", value = "Organism_part")

# Extract annotation for cell type
Gbm_annotations_cell_type <- sapply(Gbm_datasets_filtered$experiment.shortName,
                                    ExtractAnnotations,
                                    annotation_class_name = "cell type") %>%
  # Transform into a dataframe
  enframe(name = "experiment.shortName", value = "Cell_type")

# Extract annotation for developmental stage
Gbm_annotations_dev_stage <- sapply(Gbm_datasets_filtered$experiment.shortName,
                                    ExtractAnnotations,
                                    annotation_class_name = "developmental stage") %>%
  # Transform into a dataframe
  enframe(name = "experiment.shortName", value = "Developmental_stage")

# Extract annotation for treatment
Gbm_annotations_treatment <- sapply(Gbm_datasets_filtered$experiment.shortName,
                                    ExtractAnnotations,
                                    annotation_class_name = "treatment") %>%
  # Transform into a dataframe
  enframe(name = "experiment.shortName", value = "Treatment")

# Extract annotation for disease
Gbm_annotations_disease <- sapply(Gbm_datasets_filtered$experiment.shortName,
                                  ExtractAnnotations,
                                  annotation_class_name = "disease") %>%
  # Transform into a dataframe
  enframe(name = "experiment.shortName", value = "Disease")

# Extract annotation for disease model
Gbm_annotations_dis_model <- sapply(Gbm_datasets_filtered$experiment.shortName,
                                    ExtractAnnotations,
                                    annotation_class_name = "Disease model") %>%
  # Transform into a dataframe
  enframe(name = "experiment.shortName", value = "Disease_model")

# Extract annotation for genotype
Gbm_annotations_geno <- sapply(Gbm_datasets_filtered$experiment.shortName,
                               ExtractAnnotations,
                               annotation_class_name = "genotype") %>%
  # Transform into a dataframe
  enframe(name = "experiment.shortName", value = "Genotype")

# Extract annotation for strain
Gbm_annotations_strain <- sapply(Gbm_datasets_filtered$experiment.shortName,
                                 ExtractAnnotations,
                                 annotation_class_name = "strain") %>%
  # Transform into a dataframe
  enframe(name = "experiment.shortName", value = "Strain")

# Extract annotation for biological sex
Gbm_annotations_sex <- sapply(Gbm_datasets_filtered$experiment.shortName,
                              ExtractAnnotations,
                              annotation_class_name = "biological sex") %>%
  # Transform into a dataframe
  enframe(name = "experiment.shortName", value = "Biological_sex")
```


#### 4) Extraction of Factors in Experimental Design of Each Dataset

Sometimes it is difficult to determine from the abstract and dataset annotation 
which variables were *actually manipulated* as part of the experiment. 

This can be especially true for datasets that were part of much larger studies 
containing multiple experiments.

Gemma's information about the experimental design for the transcriptional profiling 
experiment can clarify this. 

```{r func_extract_factor, cache = TRUE}
# Create a function to extract factors in experimental design 
ExtractFactors <- function(dataset_shortname){
  # Create a dataframe to store the results
  factor_df <- data.frame(
    experiment.shortName = dataset_shortname,
    factor_info = vector(mode = "character", 
                         length = length(dataset_shortname)),
    treatment_factor_info = vector(mode = "character", 
                                   length = length(dataset_shortname)),
    baseline_factor_info = vector(mode = "character", 
                                   length = length(dataset_shortname)),
    stringsAsFactors = FALSE
  )
  
  # Loop through each of the dataset 
  for (i in c(1:length(dataset_shortname))){
    
    # Extract the differential expression analysis from the datasets 
    design <- get_dataset_differential_expression_analyses(dataset_shortname[i])
    
    if(nrow(design) > 0){
    # Concatenate the factor categories into a single string
    factor_df$factor_info[i] <- paste(design$factor.category, collapse = ";")
    
    # Concatenate the experimental factors into a single string
    treatment_factor <- sapply(design$experimental.factors, function(f) f$summary)
    factor_df$treatment_factor_info[i] <- paste(treatment_factor, collapse = ";")
    
    # Concatenate the baseline factors into a single string 
    baseline_factor <- sapply(design$baseline.factors, function(f) f$summary)
    factor_df$baseline_factor_info[i] <- paste(baseline_factor, collapse = ";")
    }
  }
  # Return the final dataframe 
  return(factor_df)
}  
```


```{r run_extract_factor, cache = TRUE}
# Function use 
Gbm_annotations_factor <- ExtractFactors(Gbm_datasets_filtered$experiment.shortName)
```


```{r data_combine, cache = TRUE}
# Combine all annotations by experiment.shortName and create extra columns in 
# the final dataframe
Gbm_annotations_all <- Gbm_datasets_filtered %>%
  left_join(Gbm_annotations_organism_part, by = "experiment.shortName") %>%
  left_join(Gbm_annotations_cell_type, by = "experiment.shortName") %>%
  left_join(Gbm_annotations_dev_stage, by = "experiment.shortName") %>%
  left_join(Gbm_annotations_treatment, by = "experiment.shortName") %>%
  left_join(Gbm_annotations_disease, by = "experiment.shortName") %>%
  left_join(Gbm_annotations_dis_model, by = "experiment.shortName") %>%
  left_join(Gbm_annotations_geno, by = "experiment.shortName") %>%
  left_join(Gbm_annotations_strain, by = "experiment.shortName") %>%
  left_join(Gbm_annotations_sex, by = "experiment.shortName") %>%
  left_join(Gbm_annotations_factor, by = "experiment.shortName") %>%

  # Add empty columns to store screening notes 
  mutate(Manipulation_unrelated_to_topic = 
           vector(mode = "character", length = nrow(.)), 
         Incorrect_developmental_stage = 
           vector(mode = "character", length = nrow(.)), 
         Not_bulk_dissection_Particular_Cell_type_or_Subregion = 
           vector(mode = "character", length = nrow(.)),
         Not_full_transcriptome = 
           vector(mode = "character", length = nrow(.)),
         Metadata_issues_Missing_info_NoPub_Retracted_Duplicated = 
           vector(mode = "character", length = nrow(.)),
         Excluded = 
           vector(mode = "character", length = nrow(.)), 
         Excluded_reason = 
           vector(mode = "character", length = nrow(.)),
         Included = 
           vector(mode = "character", length = nrow(.)))

# Transform the annotations into characters
Gbm_annotations_all$Organism_part <- as.character(Gbm_annotations_all$Organism_part)
Gbm_annotations_all$Cell_type <- as.character(Gbm_annotations_all$Cell_type)
Gbm_annotations_all$Developmental_stage <- as.character(Gbm_annotations_all$Developmental_stage)
Gbm_annotations_all$Treatment <- as.character(Gbm_annotations_all$Treatment)
Gbm_annotations_all$Disease <- as.character(Gbm_annotations_all$Disease)
Gbm_annotations_all$Disease_model <- as.character(Gbm_annotations_all$Disease_model)
Gbm_annotations_all$Genotype <- as.character(Gbm_annotations_all$Genotype)
Gbm_annotations_all$Strain <- as.character(Gbm_annotations_all$Strain)
Gbm_annotations_all$Biological_sex <- as.character(Gbm_annotations_all$Biological_sex)

# Extract the final dataframe into CSV
write_csv(Gbm_annotations_all, "All_datasets_with_annotations.csv")
# str(gbm_annotations_all)
```

Through initial selection process, 6 datasets are possible, including: GSE154958,
GSE15209, GSE45899, GSE135306, GSE4536, GSE75147


### 5) Gene Expression Range Assessment

```{r func_check_gene_express}
# Create a function to check the expression range of the dataset 
# (especially for the Agilent microarray datasets)
CheckGeneExpressionRange <- function(dataset_shortname){
  
  # Retrieve the processed expression data for the given dataset
  expression_data <- get_dataset_processed_expression(dataset_shortname)
  
  # Print the structure of the expression data
  print(str(expression_data))
  
  # The first four columns are row metadata: Probe, GeneSymbol, GeneName, NCBI ID
  # The rest of the columns are gene expression values for each subject
  
  # Exclude metadata row (row 1-4) and convert the gene expression columns to a 
  # matrix for further analysis 
  expression_matrix <- as.matrix(expression_data[,-1:-4])
  
  # Create a histogram of the expression data 
  hist(expression_matrix, 
       main = paste("Histogram of Expression Data for", dataset_shortname),
       # The y-axis is the gene frequency
       # The x-axis is log 2 gene expression - log 2 counts per million
       xlab = "Log 2 Expression", ylab = "Frequency")
  
       # The large spike on the left side of the histogram ("floor effect") are 
       # all of the genes that are not truly expressed or have too low of expression 
       # to be measurable 
  
  # Log 2 RNA-seq dataset has the range between -5 to 12
  # Log 2 Microarray dataset has the range between 4 to 15
  
  # Calculate the min, median, max values of the expression data
  min_val <- min(expression_matrix, na.rm = TRUE)
  median_val <- median(expression_matrix, na.rm = TRUE)
  max_val <- max(expression_matrix, na.rm = TRUE)
  
  # Print the calculated values
  print(paste("Minimum value:", min_val))
  print(paste("Median value:", median_val))
  print(paste("Maximum value:", max_val))
}
```


```{r run_check_gene_express, cache = TRUE}
# Function use 
CheckGeneExpressionRange("GSE154958") # Min: -4.9 | Max: 14.1 | RNA-seq 
CheckGeneExpressionRange("GSE15209") # Min: 2.7 | Max: 14.8 | Affymetrix Array
CheckGeneExpressionRange("GSE45899") # Min: 3.6 | Max: 15.2 | Affymetrix Array
CheckGeneExpressionRange("GSE135306") # Min: -5.9 | Max: 13.5 | RNA-Seq
CheckGeneExpressionRange("GSE4536") # Min: 3.7 | Max: 14.6 | Affymetrix Array
CheckGeneExpressionRange("GSE75147") # Min: -5.9 | Max: 13.3 | RNA-Seq
```

Gene expression of all 6 datasets seem to be within normal range and have appropriate
distribution.


### 6) Extraction of Statistical Contrasts of Differential Analysis in Each Dataset

For the meta-analysis, we will be extracting the differential expression results 
from Gemma. The differential expression results for each dataset may include 
multiple result sets (e.g., one result set for the subset of the data from the 
hippocampus, one result set for frontal cortex). Each of these result sets may 
have multiple statistical contrasts (e.g., drug1 vs. vehicle, drug2 vs. vehicle). 
Therefore, each of the statistical contrasts is labeled with a result ID and 
contrast ID within the Gemma database. We will need to know which of these IDs 
are relevant to our project goals to easily extract their results.

We will also need to double-check that these statistical contrasts are set up in 
a manner that makes sense for our experiments:

1. For experiments that include more than one brain region, we will need to 
double-check that the results have been subsetted by brain region (instead of 
including brain region ("OrganismPart") as a factor in the model). If they have 
not been subsetted by region, we will probably need to re-run the differential 
expression analysis.

2. Depending on the goals of the meta-analysis, we may also need to re-run the 
differential expression analysis to remove other unwanted subjects (e.g., removing 
subjects with genotypes that might interfere with our results).

3. We will need to double-check that the comparisons include an appropriate 
reference group - sometimes they are reversed in Gemma (e.g., having the drug 
treatment set as the baseline, with vehicle as the manipulation). If this is the 
case, we will need to invert the effects when we input them into our meta-analysis 
(multiply the effects by -1).


```{r func_contrast_extract}
# Create a function to extract statistical contrasts of differential analysis 
# in each dataset 
GettingResultSetInfoForDatasets <- function(ExperimentIDs) {
  
  # Create a dataframe to store the results 
  resultsets_toscreen <- data.frame(
    ExperimentIDs = character(),
    ResultSetIDs = character(),
    ContrastIDs = character(),
    FactorCategory = character(),
    ExperimentalFactors = character(),
    BaselineFactors = character(),
    Subsetted = logical(),
    SubsetBy = character(),
    stringsAsFactors = FALSE
  )
  
  # Loop through each of the datasets 
  for (i in c(1:length(ExperimentIDs))) {
    
    # Extract the differential expression analysis from the datasets 
    design <- get_dataset_differential_expression_analyses(ExperimentIDs[i])
    
    # Check if the design dataframe has rows
    if (nrow(design) > 0) {
      
      # Create the vectors to store the experimental and baseline factors
      experimental_factors <- vector(mode = "character", length = nrow(design))
      baseline_factors <- vector(mode = "character", length = nrow(design))
      
      # Loop through each result.ID in the design dataframe
      for (j in c(1:nrow(design))) {
        
        # Concatenate the experimental factors into a single string
        experimental_factors[j] <- paste(design$experimental.factors[[j]]$summary, 
                                         collapse = ";")
        
        # Concatenate the baseline factors into a single string 
        baseline_factors[j] <- paste(design$baseline.factors[[j]]$summary, 
                                     collapse = ";")
      }
      
      # Create a vector to store subset information
      SubsetBy <- vector(mode = "character", length = nrow(design))
      
      # Check if the design dataframe is subsetted or not
      if (design$isSubset[1] == TRUE) {
        
        # Loop through each result.ID to extract and concatenate subset information
        for (j in c(1:nrow(design))) {
          SubsetBy[j] <- paste(design$subsetFactor[[j]]$summary, collapse = ";")
        } 
      } else {
        # If not subsetted, fill the SubsetBy vector with NA values 
        SubsetBy <- rep(NA, length(design$result.ID))
      }
      
      # Create a temporary dataframe to store extracted info
      resultsets_for_experiment <- data.frame(
        ExperimentIDs = ExperimentIDs[i],
        ResultSetIDs = design$result.ID,
        ContrastIDs = design$contrast.ID,
        FactorCategory = design$factor.category,
        ExperimentalFactors = experimental_factors,
        BaselineFactors = baseline_factors,
        Subsetted = design$isSubset,
        SubsetBy = SubsetBy,
        stringsAsFactors = FALSE
      )
      
      # Append the temporary dataframe with the dataframe created initially
      resultsets_toscreen <- rbind(resultsets_toscreen, resultsets_for_experiment)
      
    }
  }
  
  # Add empty columns to store screening notes 
  resultsets_toscreen <- cbind(
    resultsets_toscreen,
    Include = vector(mode = "character", length = nrow(resultsets_toscreen)),
    WrongBaseline = vector(mode = "character", length = nrow(resultsets_toscreen)),
    ResultsNotRegionSpecific = vector(mode = "character", length = nrow(resultsets_toscreen)),
    ReAnalyze = vector(mode = "character", length = nrow(resultsets_toscreen)),
    stringsAsFactors = FALSE
  )
  
  # Export the final dataframe into the working directory
  write.csv(resultsets_toscreen, "ResultSets_toScreen.csv")
  
  # Print a message to indicate that the results have been saved 
  print("Output object: ResultSets_toScreen.csv")
}
```


```{r run_contrast_extract, cache = TRUE}
# Set up a vector of the names of all datasets
ExperimentIDs <- c("GSE154958", "GSE15209", "GSE45899", 
                   "GSE135306", "GSE4536","GSE75147")

# Function use
GettingResultSetInfoForDatasets(ExperimentIDs)
```


Through secondary selection process, contrast 40036 of GSE15209, contrast 94018 of
GSE45899, contrast 121770 and 121772 of GSE75147 were included in the meta-analysis.


### 7) Downloading the DE Results from Each Dataset

```{r func_download_DEResults}
# Create a function to download DE results and extract Log2FC and T-statistics 
# for contrasts of interest 
DownloadingDEResults <- function(ResultSets_contrasts){
  
  # Identify the unique ResultSet IDs
  # Some ResultSets may have multiple statistical contrasts, but we only want unique ResultSet IDs
  UniqueResultSetIDs <- unique(ResultSets_contrasts$ResultSetIDs) 
  
  # Print the identified unique ResultSet IDs
  print("ResultSets identified as being of interest:")
  print(UniqueResultSetIDs)
  
  # Download DE results for each unique ResultSet ID
  differentials <- UniqueResultSetIDs %>%
    # The function returns a list because single experiment may have multiple 
    # resultSets
    # Only take the first element of the output
    # The "resultSet" argument is used to directly access the results we need
    lapply(function(x) {get_differential_expression_values(resultSets = x)[[1]]})
  
  # Some datasets might not have all the advertised DE results due to a variety of
  # so we need to remove empty differential (only keep differential with rows present)
  non_missing_contrasts <- sapply(differentials, function(df) nrow(df) > 0)
  
  # Return the "differentials" object that contains the DE results of contrast of interest
  differentials <<- differentials[non_missing_contrasts] 
  UniqueResultSetIDs <<- UniqueResultSetIDs[non_missing_contrasts]
  
  # Print the ResultSet IDs that had DE results
  print("ResultSets that had DE results:")
  print(UniqueResultSetIDs)
  
  # Print a message to inform the structure of the output "differentials"
  print("Your DE results for each of the ResultSets are stored in object differentials.")
  print("This object is structured as a list of dataframes.")
  print("Each element in the list represents a ResultSet, with the dataframe containing DE results")
  
  # Extract the effect sizes of Log2FC of contrasts of interest
  print("Columns of effect sizes (Log2FC) for contrasts of interest:")
  Contrasts_Log2FC <- paste("contrast_", ResultSets_contrasts$ContrastIDs, 
                             "_log2fc", sep = "")
  print(Contrasts_Log2FC)
  
  # Extract the T-statistics of contrasts of interest for calculating sampling variances
  print("Columns of T-statistics for contrasts of interest:")
  Contrasts_Tstat <- paste("contrast_", ResultSets_contrasts$ContrastIDs,
                            "_tstat", sep = "")
  print(Contrasts_Tstat)
  
  # Remove the temporary Log2FC and T-statistics of contrast of interest
  rm(Contrasts_Log2FC, Contrasts_Tstat)
}
```


```{r run_download_DEResults, cache = TRUE}
# Import the CSV file with contrasts of interest
ResultSets_contrasts <- read.csv("ResultSets_Screened.csv", 
                                 header = TRUE, stringsAsFactors = FALSE)
# Function use
DownloadingDEResults(ResultSets_contrasts)

# Contrast 94078 in GSE45889 compares neural stem cells (NSC) vs glioblastoma stem
# cells (GSC), which is opposite in direction to the other datasets. To align the
# comparisons (GSC vs NSC), we reverse the coefficient, T-statistic, and Log2FC 
# for consistency across all datasets.

# Access DE results of GSE45889 from "differentials" object
GSE45889 <- differentials[[2]]

# Reverse the coefficient, Tstat, and Log2FC of contrast 94074 
GSE45889$contrast_94074_coefficient <- -1*GSE45889$contrast_94074_coefficient
GSE45889$contrast_94074_log2fc <- -1*GSE45889$contrast_94074_log2fc
GSE45889$contrast_94074_tstat <- -1*GSE45889$contrast_94074_tstat

# Reverse the coefficient, Tstat, and Log2FC of contrast 94076 
GSE45889$contrast_94076_coefficient <- -1*GSE45889$contrast_94076_coefficient
GSE45889$contrast_94076_log2fc <- -1*GSE45889$contrast_94076_log2fc
GSE45889$contrast_94076_tstat <- -1*GSE45889$contrast_94076_tstat

# Reverse the coefficient, Tstat, and Log2FC of contrast 94077
GSE45889$contrast_94077_coefficient <- -1*GSE45889$contrast_94077_coefficient
GSE45889$contrast_94077_log2fc <- -1*GSE45889$contrast_94077_log2fc
GSE45889$contrast_94077_tstat <- -1*GSE45889$contrast_94077_tstat 

# Reverse the coefficient, Tstat, and Log2FC of contrast 94078
GSE45889$contrast_94078_coefficient <- -1*GSE45889$contrast_94078_coefficient
GSE45889$contrast_94078_log2fc <- -1*GSE45889$contrast_94078_log2fc
GSE45889$contrast_94078_tstat <- -1*GSE45889$contrast_94078_tstat 

# Replace the original dataset with the reversed one
differentials[[2]] <- GSE45889

# Remove the temporary reversed dataset
rm(GSE45889)

# Check the structure of the "differentials" object
str(differentials)
```


```{r func_save_DEResults}
# Create a function to save DE results for each ResultSet
SavingGemmaDEResults_forEachResultSet <- function(differentials, 
                                                  UniqueResultSetIDs, 
                                                  ResultSets_contrasts){
    
  # Loop through each dataset (list element) in "differentials" object
  for (i in c(1:length(differentials))){
    
    # Get the current ResultSet ID
    ThisResultSet <- UniqueResultSetIDs[i]
    
    # Get the dataset ID corresponding to the current ResultSet ID
    # Some datasets have multiple ResultSets, so take the dataset ID from the 
    # first matching entry
    ThisDataSet <- ResultSets_contrasts$ExperimentID[ResultSets_contrasts$ResultSetIDs == ThisResultSet][1] 
    
    # Export the DE results for the current ResultSet ID into the working directory
    write.csv(differentials[[i]], paste("DEResults_", ThisDataSet, "_", ThisResultSet, ".csv", sep=""))
    
    # Remove the temporary IDs
    rm(ThisDataSet, ThisResultSet)
   }
  
  # Print a message to indicate the DE results have been exported into working directory
  print("Output object: DEResults_Dataset ID_ResultSet ID")
}
```


```{r run_save_DEResults, cache = TRUE}
# Function use
SavingGemmaDEResults_forEachResultSet(differentials, 
                                      UniqueResultSetIDs,
                                      ResultSets_contrasts)
```


### 8) Filter of DE results for rows with good gene annotation

```{r func_gene_filter}
# Create a function to filter for rows with good gene annotation 
FilteringDEResults_GoodAnnotation <- function(DE_Results){
  
  # Print the total number of rows in the DE results
  print("# of rows in results")
  print(nrow(DE_Results))
  
  # Print the number of rows with missing NCBI annotation
  print("# of rows with missing NCBI annotation:")
  print(sum(DE_Results$NCBIid == "" | DE_Results$NCBIid == "null", na.rm = TRUE))
  
  # Print the number of rows with NA NCBI annotation
  print("# of rows with NA NCBI annotation:")
  print(sum(is.na(DE_Results$NCBIid)))
  
  # Print the number of rows with missing Gene Symbol annotation
  print("# of rows with missing Gene Symbol annotation:")
  print(sum(DE_Results$GeneSymbol == ""| DE_Results$GeneSymbol == "null", na.rm = TRUE))
  
  # Print the number of rows mapped to multiple NCBI IDs
  print("# of rows mapped to multiple NCBI IDs:")
  print(length(grep('\\|', DE_Results$NCBIid)))
  
  # Print the number of rows mapped to multiple Gene Symbols
  print("# of rows mapped to multiple Gene Symbols:")
  print(length(grep('\\|', DE_Results$GeneSymbol)))
  
  # Subset data containing rows with valid NCBI EntrezID (non-empty and non-null)
  DE_Results_NoNA <- DE_Results[(DE_Results$NCBIid == "" | 
                                 DE_Results$NCBIid == "null") == FALSE & 
                                 is.na(DE_Results$NCBIid) == FALSE,]
  
  # Subset data annotated with a single gene (not ambiguously mapped to more 
  # than one gene)
  if(length(grep('\\|', DE_Results_NoNA$NCBIid)) == 0){
    # If there are no rows with multiple NCBI IDs, use the current subset
    DE_Results_GoodAnnotation <- DE_Results_NoNA
  } else {
    # Extract only rows annotated with a single Gene Symbol (no pipe character '|')
    DE_Results_GoodAnnotation <- DE_Results_NoNA[-(grep('\\|', DE_Results_NoNA$NCBIid)),]
  }

  # Print the number of rows with good annotation
  print("# of rows with good annotation")
  print(nrow(DE_Results_GoodAnnotation))
  
  # Get the name of the input object as a string for file naming
  ID <- deparse(substitute(DE_Results))
  
  # Export the DE results with good annotations into the working directory
  write.csv(DE_Results_GoodAnnotation, paste(ID, "_GoodAnnotation.csv", sep = ""))
  
  # Remove the temporary DE result objects
  rm(DE_Results_NoNA, DE_Results)
  
  # Print a message to the DE results with good annotations have been exported 
  # into working directory 
  print(paste("Output object:", ID, "_GoodAnnotation.csv", sep = ""))
  
  # Return the DE results with good annotation into the environment
  return(DE_Results_GoodAnnotation)
}
```


```{r run_gene_filter, cache = TRUE}
# Separate the DE results from object "differentials"
DEResults_GSE15209 <- differentials[[1]]
DEResults_GSE45899 <- differentials[[2]]
DEResults_GSE75147 <- differentials[[3]]


# Function use
DE_Results_GSE15209_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE15209)
DE_Results_GSE45899_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE45899)
DE_Results_GSE75147_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE75147)

# Check the structure of the DE results with good annotations 
# str(DE_Results_GSE15209_GoodAnnotation)
# str(DE_Results_GSE45899_GoodAnnotation)
# str(DE_Results_GSE75147_GoodAnnotation)
```


### 9) Extraction of DE results for the contrasts of interest

```{r func_extract_contrastID}
# Create a function to extract the contrast ID from FC column names 
GetContrastIDsforResultSet <- function(NamesOfFoldChangeColumns){
  
  # Split the column names using the underscore as a delimiter
  # The result is a list where each element is a vector of the split parts of 
  # each column name
  ColumnNames_BrokenUp <- strsplit(NamesOfFoldChangeColumns, "_")
  
  # Convert the list of split names to a matrix
  MatrixOfColumnNames_BrokenUp <- do.call(rbind, ColumnNames_BrokenUp)
  
  # Extract the contrast IDs in the second column
  ContrastIDs_inCurrentDF <- MatrixOfColumnNames_BrokenUp[, 2]
  
  # Return the extracted contrast ID
  return(ContrastIDs_inCurrentDF)
}
```


```{r func_extract_contrast_DEResults}
# Create a function to extract DE results for contrasts of interest
ExtractingDEResultsForContrasts <- function(DE_Results_GoodAnnotation, 
                                            Contrasts_Log2FC, 
                                            Contrasts_Tstat, 
                                            ResultSet_contrasts){
  
    # Print the column names in the DE results with good annotations for the 
    # current ResultSet
    print("Columns in the DE results for the current ResultSet:")
    print(colnames(DE_Results_GoodAnnotation))
  
    # Print the column names that correspond to Log2FC values for contrasts of interest
    print("Columns of Log2FC for contrasts of interest within the DE results for the current ResultSet:")
    NamesOfFoldChangeColumns <- colnames(DE_Results_GoodAnnotation)[colnames(DE_Results_GoodAnnotation) %in% Contrasts_Log2FC]
    print(NamesOfFoldChangeColumns)
  
    # Print the column names that correspond to T-statistics values for contrasts of interest
    print("Columns of T-statistics for contrasts of interest within the DE results for the current ResultSet:")
    NamesOfTstatColumns <- colnames(DE_Results_GoodAnnotation)[colnames(DE_Results_GoodAnnotation) %in% Contrasts_Tstat]
    print(NamesOfTstatColumns)
  
    # Extract contrast IDs from FC column names using the function "GetContrastIDsforResultSet"
    ContrastIDs_inCurrentDF <- GetContrastIDsforResultSet(NamesOfFoldChangeColumns)
    print("Contrast IDs for contrasts of interest within the current ResultSet:")
    print(ContrastIDs_inCurrentDF)
  
    # Extract dataset IDs for contrasts of interest
    DatasetIDs <- ResultSet_contrasts$ExperimentID[ResultSet_contrasts$ContrastIDs %in% ContrastIDs_inCurrentDF]
    print("Dataset ID for the ResultSet and contrasts:")
    print(DatasetIDs)
  
    # Extract experimental factors for contrasts of interest
    Factors_inCurrentDF <- ResultSet_contrasts$ExperimentalFactors[ResultSet_contrasts$ContrastIDs %in% ContrastIDs_inCurrentDF]
    print("Experimental factors for ResultSet and contrasts:")
    print(Factors_inCurrentDF)
  
    # Combine dataset IDs and experimental factors to create unique identifiers 
    # for each statistical comparison
    ComparisonsOfInterest <- paste(DatasetIDs, Factors_inCurrentDF, sep = "_")
    print("Current names of contrasts of interest")
    print(ComparisonsOfInterest)
  
    # Create a list to store extracted DE results and relevant metadata
    DE_result_contrast <- list(
      All_Columns = colnames(DE_Results_GoodAnnotation),
      NamesOfFoldChangeColumns = NamesOfFoldChangeColumns,
      NamesOfTstatColumns = NamesOfTstatColumns,
      Contrast_ID = ContrastIDs_inCurrentDF,
      Dataset_ID = DatasetIDs,
      Experimental_Factor = Factors_inCurrentDF,
      ComparisonsOfInterest = ComparisonsOfInterest
  )
    # Return the list of all extracted info
    return(DE_result_contrast)
}
```


```{r func_extract_contrast_stat}
# Create a function to extract the Log2FC and T-statistics of contrast of interest
GetContrastStatColumns <- function(ResultSets_contrasts){
  
  # Extract the effect sizes (Log2FC) of contrasts of interest
  Contrasts_Log2FC <- paste("contrast_", ResultSets_contrasts$ContrastIDs, "_log2fc", sep = "")

  # Extract the T-statistics of contrasts of interest for calculating sampling variances
  Contrasts_Tstat <- paste("contrast_", ResultSets_contrasts$ContrastIDs, "_tstat", sep = "")

  # Create a dataframe to store the extracted information
  Contrasts_Stat <- data.frame(
    ExperimentID = ResultSets_contrasts$ExperimentIDs,
    ContrastID = ResultSets_contrasts$ContrastIDs,
    Log2FC_Column = Contrasts_Log2FC,
    Tstat_Column = Contrasts_Tstat,
    stringsAsFactors = FALSE
  )
  
  # Return the resulting dataframe
  return(Contrasts_Stat)
}
```


```{r run_extract_contrast_stat, cache = TRUE}
# Function use
Contrasts_Stat_Columns <- GetContrastStatColumns(ResultSets_contrasts)
```


```{r prep_contrast_stat, cache = TRUE}
# Prepare "Contrast_Log2FC" and "Contrast_Tstat" arguments for extracting DE results 
# of contrasts of interest

# GSE15209
Contrasts_Log2FC_GSE15209 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE15209") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE15209 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE15209") %>%
  pull(Tstat_Column)

# GSE45899 
Contrasts_Log2FC_GSE45899 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE45899") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE45899 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE45899") %>%
  pull(Tstat_Column)

# GSE75147
Contrasts_Log2FC_GSE75147 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE75147") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE75147 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE75147") %>%
  pull(Tstat_Column)
```


```{r run_extract_contrast_DEResults, cache = TRUE}
# Function use

# GSE15209
DE_Results_Contrasts_GSE15209 <- ExtractingDEResultsForContrasts(DE_Results_GSE15209_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE15209,
                                                                 Contrasts_Tstat_GSE15209,
                                                                 ResultSets_contrasts)

# GSE45899
DE_Results_Contrasts_GSE45899 <- ExtractingDEResultsForContrasts(DE_Results_GSE45899_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE45899,
                                                                 Contrasts_Tstat_GSE45899,
                                                                 ResultSets_contrasts)

# GSE75147
DE_Results_Contrasts_GSE75147 <- ExtractingDEResultsForContrasts(DE_Results_GSE75147_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE75147,
                                                                 Contrasts_Tstat_GSE75147,
                                                                 ResultSets_contrasts)
```


### 10) Collapse of DE results to one result per gene & Calculation of standard 
### error and sampling variance

Gene expression can be measured using multiple probes (microarray). Therefore,
DE results need to be collapsed to one result per gene.

Standard error of Log2FC = Log2FC/T-statistics

Sampling variance = Average of standard error of each gene^2 


```{r func_collapse_contrast_DEResults}
# Create a function to average Log2FC, Tstat, standard error to one unique gene 
# per dataset 
CollapsingDEResults_OneResultPerGene<-function(GSE_ID, 
                                               DE_Results_GoodAnnotation, 
                                               ComparisonsOfInterest, 
                                               NamesOfFoldChangeColumns, 
                                               NamesOfTstatColumns){
  
  # Print a message to check if the vectors containing FC and T-stat column names 
  # are in the same order as the comparisons of interest
  print("Check if the vectors containing FC and Tstat column names contain the same order as the comparison of interest")
  
  # Print the number of unique NCBI IDs in the DE results
  print("# of rows with unique NCBI IDs:")
  print(length(unique(DE_Results_GoodAnnotation$NCBIid)))
  
  # Print the number of unique Gene Symbols in the DE results
  print("# of rows with unique Gene Symbols:")
  print(length(unique(DE_Results_GoodAnnotation$GeneSymbol)))
  
  # Create a folder named after the dataset ID to store results
  dir.create(paste("./", "Collapsing_DEResults_", GSE_ID, sep=""))
  
  # Set the working directory to the newly created folder
  setwd(paste("./", "Collapsing_DEResults_", GSE_ID, sep=""))
  
  # Create lists to store results
  DE_Results_GoodAnnotation_FoldChange_Average <- list()
  DE_Results_GoodAnnotation_Tstat_Average <- list()
  DE_Results_GoodAnnotation_SE_Average <- list()
  
  # Loop through each column containing FC and T-statistic info for the contrasts of interest
  for(i in c(1:length(NamesOfFoldChangeColumns))){
    
    # Select the Log2FC column of interest
    FoldChangeColumn <- dplyr::select(DE_Results_GoodAnnotation, NamesOfFoldChangeColumns[i])
    
    # Select the T-stat column of interest
    TstatColumn <- dplyr::select(DE_Results_GoodAnnotation, NamesOfTstatColumns[i])
    
    # Calculate the standard error (SE)
    DE_Results_GoodAnnotation_SE <- FoldChangeColumn[[1]]/TstatColumn[[1]]
    
    # Calculate the average Log2FC per gene
    DE_Results_GoodAnnotation_FoldChange_Average[[i]] <- tapply(FoldChangeColumn[[1]], 
                                                                DE_Results_GoodAnnotation$NCBIid, 
                                                                mean)
    
    # Calculate the average T-statistics per gene
    DE_Results_GoodAnnotation_Tstat_Average[[i]] <- tapply(TstatColumn[[1]], 
                                                           DE_Results_GoodAnnotation$NCBIid, 
                                                           mean)
    
    # Calculate the average SE per gene
    DE_Results_GoodAnnotation_SE_Average[[i]] <- tapply(DE_Results_GoodAnnotation_SE, 
                                                        DE_Results_GoodAnnotation$NCBIid, 
                                                        mean)
    
  }
  
  # Combine averaged Log2FC values into a single dataframe 
  DE_Results_GoodAnnotation_FoldChange_AveragedByGene <- do.call(cbind, DE_Results_GoodAnnotation_FoldChange_Average)
  
  # Print the dimensions of the averaged Fold Change matrix
  print("Dimensions of Fold Change matrix, averaged by gene symbol:")
  print(dim(DE_Results_GoodAnnotation_FoldChange_AveragedByGene))
  
  # Name the columns in the dataframe to describe the contrast of interest
  colnames(DE_Results_GoodAnnotation_FoldChange_AveragedByGene) <- ComparisonsOfInterest
  
  # Export the averaged Log2FC results into the working directory
  write.csv(DE_Results_GoodAnnotation_FoldChange_AveragedByGene, 
            paste("DEResults_", GSE_ID, "_GoodAnnotation_FoldChange_AveragedByGene.csv", sep = ""))
  
  # Combine T-statistics values into a single dataframe 
  DE_Results_GoodAnnotation_Tstat_AveragedByGene<-do.call(cbind, DE_Results_GoodAnnotation_Tstat_Average)
  
  # Name the columns in the dataframe to describe the contrast of interest
  colnames(DE_Results_GoodAnnotation_Tstat_AveragedByGene) <- ComparisonsOfInterest
  
  # Export the averaged T-statistics results into the working directory
  write.csv(DE_Results_GoodAnnotation_Tstat_AveragedByGene, 
            paste("DEResults_", GSE_ID, "_GoodAnnotation_Tstat_AveragedByGene.csv", sep = ""))
  
  # Combine SE values into a single dataframe 
  DE_Results_GoodAnnotation_SE_AveragedByGene<-do.call(cbind, DE_Results_GoodAnnotation_SE_Average)
  
  # Name the columns in the dataframe to describe the contrast of interest
  colnames(DE_Results_GoodAnnotation_SE_AveragedByGene) <- ComparisonsOfInterest
  
  # Export the averaged SE results into the working directory
  write.csv(DE_Results_GoodAnnotation_SE_AveragedByGene, 
            paste("DEResults_", GSE_ID, "_GoodAnnotation_SE_AveragedByGene.csv", sep = ""))
  
  # Calculate the sampling variance (SV) by squaring the SE
  DE_Results_GoodAnnotation_SV <- (DE_Results_GoodAnnotation_SE_AveragedByGene)^2
  
  # Export the SV results into the working directory
  write.csv(DE_Results_GoodAnnotation_SV, 
            paste("DEResults_", GSE_ID, "_GoodAnnotation_SV.csv", sep = ""))
  
  # Compile all averaged results into a single list 
  TempMasterResults<-list(Log2FC = DE_Results_GoodAnnotation_FoldChange_AveragedByGene,
                          Tstat = DE_Results_GoodAnnotation_Tstat_AveragedByGene, 
                          SE = DE_Results_GoodAnnotation_SE_AveragedByGene, 
                          SV = DE_Results_GoodAnnotation_SV)
  
  # Print the name of the output
  print(paste("Output: Collapsing_DEResults", GSE_ID, sep="_"))
  
  # Clean up the environment by removing temporary results
  rm(DE_Results_GoodAnnotation, DE_Results_GoodAnnotation_SV, 
     DE_Results_GoodAnnotation_SE, DE_Results_GoodAnnotation_FoldChange_AveragedByGene,
     DE_Results_GoodAnnotation_FoldChange_Average, DE_Results_GoodAnnotation_Tstat_AveragedByGene,
     DE_Results_GoodAnnotation_Tstat_Average, DE_Results_GoodAnnotation_SE_Average, 
     FoldChangeColumn, TstatColumn, GSE_ID, ComparisonsOfInterest, NamesOfFoldChangeColumns, 
     NamesOfTstatColumns)
  
  # Set the working directory back to the parent directory
  setwd("../")
  
  # Return the compiled results
  return(TempMasterResults)
}
```


```{r prep_col_name, cache = TRUE}
# Prepare "NamesOfFoldChangeColumns" and "NamesOfTstatColumns" arguments for  
# extracting DE results of contrasts of interest

# GSE15209
# GSC cell lines: G144 (GBM), G166 (GBM), GliN2 (GBM), G179 (Giant cell GBM), 
# G174 (anaplastic oligoastrocytoma)
# NSC cell line: Fetal neural stem cells
NamesOfFoldChangeColumns_GSE15209 <- DE_Results_Contrasts_GSE15209[[2]]
NamesOfTstatColumns_GSE15209 <- DE_Results_Contrasts_GSE15209[[3]]
ComparisonsOfInterest_GSE15209 <- c("GSE15209_G144.GBM_vs_Fetal.NSC", "GSE15209_G174.AnaOlig_vs_Fetal.NSC")

# GSE45899
# GSC cell lines: MGG4 (GBM), MGG6 (GBM), MGG8 (GBM) 
# NSC cell line: Human embryonic stem-derived neural stem cells 
NamesOfFoldChangeColumns_GSE45899 <- DE_Results_Contrasts_GSE45899[[2]]
NamesOfTstatColumns_GSE45899 <- DE_Results_Contrasts_GSE45899[[3]]
ComparisonsOfInterest_GSE45899 <- c("GSE45899_MGG4.GBM_vs_Human.embryonic.NSC")

# GSE75147
# GSC cell lines: G144 (GBM), GSC-0827 (GBM)
# NSC cell line: Fetal neural stem cells (CB660)
NamesOfFoldChangeColumns_GSE75147 <- DE_Results_Contrasts_GSE75147[[2]]
NamesOfTstatColumns_GSE75147 <- DE_Results_Contrasts_GSE75147[[3]]
ComparisonsOfInterest_GSE75147 <- c("GSE75147_G166.GBM_vs_Fetal.NSC", "GSE75147_GSC-0827.GBM_vs_Fetal.NSC")
```


```{r run_collapse_contrast_DEResults, cache = TRUE}
# Function use

# GSE15209
Collapsing_DEResults_GSE15209 <- CollapsingDEResults_OneResultPerGene("GSE15209",
                                                                      DE_Results_GSE15209_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE15209,
                                                                      NamesOfFoldChangeColumns_GSE15209,
                                                                      NamesOfTstatColumns_GSE15209)

# GSE45899
Collapsing_DEResults_GSE45899 <- CollapsingDEResults_OneResultPerGene("GSE45899",
                                                                      DE_Results_GSE45899_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE45899,
                                                                      NamesOfFoldChangeColumns_GSE45899,
                                                                      NamesOfTstatColumns_GSE45899)

# GSE75147
Collapsing_DEResults_GSE75147 <- CollapsingDEResults_OneResultPerGene("GSE75147",
                                                                      DE_Results_GSE75147_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE75147,
                                                                      NamesOfFoldChangeColumns_GSE75147,
                                                                      NamesOfTstatColumns_GSE75147)
```


### 11) Alignment of DE results from human cell line models 

Each dataset has DE results from a slightly different list of genes.

Depending on the exact tissue dissected, the sensitivity of the transcriptional 
profiling platform, the representation on the transcriptional profiling platform 
(for microarray), and the experimental conditions, the DE results from different 
datasets will also be in a slightly different order.

We want to align these results so that the DE results from each dataset are columns, 
with each row representing a different gene.


```{r func_align_same}
# Create a function to align all mouse DE results from different datasets into
# a single dataframe for Log2FC and SV
AligningHumanDatasets <- function(ListOfHumanDEResults){
  
  # Create a list to store the log2FC 
  Human_MetaAnalysis_FoldChange_Dfs <- list()
  
  # Loop through all mouse DE results
  for(i in c(1:length(ListOfHumanDEResults))){

    # Extract the Log2FC values from each dataset and put them into separate list
    # The element from the "Collapsing_DEResults_" has the format of row names
    # as Entrez Gene ID and columns containing Log2FC values
    Human_MetaAnalysis_FoldChange_Dfs[[i]] <- data.frame(Human_EntrezGene.ID = row.names(ListOfHumanDEResults[[i]][[1]]),
                                                         ListOfHumanDEResults[[i]][[1]], 
                                                         stringsAsFactors = FALSE)
  }
  
  # Print the structure of the Log2FC lists
  print("Human_MetaAnalysis_FoldChange_Dfs:")
  print(str(Human_MetaAnalysis_FoldChange_Dfs))
  
  # ALign the DE results by Entrez Gene ID and turn them into a single dataframe
  # join_all can be used for object of list class
  Human_MetaAnalysis_FoldChanges <<- join_all(Human_MetaAnalysis_FoldChange_Dfs, 
                                              by = "Human_EntrezGene.ID", 
                                              type = "full")

  # Print the structure of the aligned Log2FC 
  print("Human_MetaAnalysis_FoldChanges:")
  print(str(Human_MetaAnalysis_FoldChanges))
  
  # Create a list to store the SV 
  Human_MetaAnalysis_SV_Dfs <- list()
  
  # Loop through all mouse DE results 
  for(i in c(1:length(ListOfHumanDEResults))){
    
    # Extract the SV values from each dataset and put them into separate list
    # The element from the "Collapsing_DEResults_" has the format of row names
    # as Entrez Gene ID and columns containing SV values
    Human_MetaAnalysis_SV_Dfs[[i]] <- data.frame(Human_EntrezGene.ID = row.names(ListOfHumanDEResults[[i]][[4]]),
                                                 ListOfHumanDEResults[[i]][[4]], 
                                                 stringsAsFactors = FALSE)
  }
  
  # Print the structure of the SV lists
  print("Human_MetaAnalysis_SV_Dfs:")
  print(str(Human_MetaAnalysis_SV_Dfs))
  
  # ALign the DE results by Entrez Gene ID and turn them into a single dataframe
  # join_all can be used for object of list class
  Human_MetaAnalysis_SV <<- join_all(Human_MetaAnalysis_SV_Dfs, 
                                     by = "Human_EntrezGene.ID",
                                     type = "full")

  # Print the structure of the aligned SV 
  print("Human_MetaAnalysis_SV:")
  print(str(Human_MetaAnalysis_SV))
  
  # Remove the temporary lists of Log2FC and SV
  rm(Human_MetaAnalysis_SV_Dfs, Human_MetaAnalysis_FoldChange_Dfs)
}
```


```{r run_align_same, cache = TRUE}
# Prepare the list of collapsed mouse DE results
ListOfHumanDEResults <- list(Collapsing_DEResults_GSE15209, 
                             Collapsing_DEResults_GSE45899,
                             Collapsing_DEResults_GSE75147)

# Function use
AligningHumanDatasets(ListOfHumanDEResults)

# Rename the output objects for the pipeline
MetaAnalysis_FoldChanges <- Human_MetaAnalysis_FoldChanges
MetaAnalysis_SV <- Human_MetaAnalysis_SV
```


### 12) Comparison of Log2FC across datasets

```{r col_names_meta}
# Check the column names in the MetaAnalysis dataframes
colnames(MetaAnalysis_FoldChanges)
```

There are different ways to plot relationships across datasets:

1. Rank-rank hypergeometric overlap plots 

2. Hierarchically clustered heatmaps

We can generally compare the DE results associated with different contrasts 
using a scatter plot and correlation analysis.

```{r cor_matrix, cache = TRUE}
# Create a correlation matrix for Log2FC across datasets
# "pairwise.complete.obs" ignore any rows of DE results that do not have Log2FC 
# for one of our columns
MetaAnalysis_CorMatrix_FoldChanges <- cor(as.matrix(MetaAnalysis_FoldChanges[,-c(1)]), 
                                                    use = "pairwise.complete.obs",
                                                    method = "spearman")
# Check the correlation matrix
MetaAnalysis_CorMatrix_FoldChanges
```

Each cell includes the correlation coefficient reflecting the similarity of the 
effect sizes for the comparison of between the contrast in the row and the according
contrast in the column.

Correlation coefficient ranges between -1 to 1, with -1 being a perfect negative 
correlation and +1 being a perfect positive correlation

```{r heatmap, cache = TRUE}
# Illustrate the correlation matrix with hierarchically clustered heatmap

# Blues Palette
# png("MetaAnalysis_CorMatrix_FoldChanges_1.png", 8, 5, "in", res = 300)
pheatmap(MetaAnalysis_CorMatrix_FoldChanges,
         display_numbers = TRUE,
         fontsize = 10,
         number_format = "%.2f", 
         color = colorRampPalette(brewer.pal(5, "Blues"))(100),
         border_color = "black",
         number_color = "black")
# dev.off()

# Oranges Palette
# png("MetaAnalysis_CorMatrix_FoldChanges_2.png", 8, 5, "in", res = 300)
pheatmap(MetaAnalysis_CorMatrix_FoldChanges,
         display_numbers = TRUE,
         fontsize = 10,
         number_format = "%.2f", 
         color = colorRampPalette(brewer.pal(5, "Oranges"))(100),
         border_color = "black",
         number_color = "black")
# dev.off()

# Blues-Yellows Palette
# png("MetaAnalysis_CorMatrix_FoldChanges_3.png", 8, 5, "in", res = 300)
pheatmap(MetaAnalysis_CorMatrix_FoldChanges,
         display_numbers = TRUE,
         fontsize = 10,
         number_format = "%.2f", 
         color = hcl.colors(5, "BluYl"),
         border_color = "black",
         number_color = "black")
# dev.off()

# Viridis Palette
# png("MetaAnalysis_CorMatrix_FoldChanges_4.png", 8, 5, "in", res = 300)
pheatmap(MetaAnalysis_CorMatrix_FoldChanges,
         display_numbers = TRUE,
         fontsize = 10,
         number_format = "%.2f", 
         color = viridis(5),
         border_color = "black",
         number_color = "black")
# dev.off()

# The groups are placed in order by similarity, as determined by hierarchical clustering
# The lines ("tree branches") on the left and top illustrate that similarity (clustering) 
# using a "dendrogram"
```


### 13) Meta-analysis with random effect models

The meta-analysis is performed using the effect sizes (Log2FC) and sampling variances
(SV) for each gene stored in the objects *MetaAnalysis_FoldChanges* and *MetaAnalysis_SV*.

For any particular gene, it is likely that some datasets may be missing DE results.
This is especially true for genes that have low levels of expression and may not 
be detected by less sensitive assays. It is also likely to be true for genes that 
were discovered more recently (i.e., not targeted by older microarray platforms)
or that lack a clear ortholog in rat/mouse.

We can only run a meta-analysis if there DE results from more than 1 statistical
contrast. Since the DE results from the same study (dataset) are often artificially
correlated (especially if they use the same control group as the comparison), we 
would prefer that there are results from more than 1 dataset (not just more than
1 statistical contrast)

Before the meta-analysis, we need to decide the minimum number of DE results allowed
for a gene to be included.

```{r cal_NA_meta, cache = TRUE}
# Calculate the number of NAs (the number of statistical contrasts lacking DE
# results) in each row (for each gene)
MetaAnalysis_FoldChanges_NAsPerRow <- apply(MetaAnalysis_FoldChanges[,-c(1)], 
                                            1, 
                                            function(y) sum(is.na(y)))

# Visualize the distribution of the NAs with histogram
hist(MetaAnalysis_FoldChanges_NAsPerRow)

# Viusalize the distribution of the NAs with table 
table(MetaAnalysis_FoldChanges_NAsPerRow)

# This table tells us how many genes (rows) contain each number of NAs 
# Ex: There are 15952 genes that contain no NA, meaning that these 15952 genes can 
# be found across all datasets
# Ex: There are 3600 genes that contain 2 NA in 2 of the 5 contrasts
```


```{r func_meta}
# Create a function to run the meta-analysis
RunBasicMetaAnalysis <- function(NumberofComparisons,
                                 CutOffForNAs,
                                 MetaAnalysis_FoldChanges,
                                 MetaAnalysis_SV){
  
  # Calculate the number of NAs (the number of statistical contrasts lacking DE
  # results) in each row (for each gene)
  MetaAnalysis_FoldChanges_NAsPerRow <- apply(MetaAnalysis_FoldChanges[,-c(1)], 
                                              1, 
                                              function(y) sum(is.na(y)))
  
  # Print the number of NAs per gene
  print("Table of # of NAs per Row (Gene):")
  print(table(MetaAnalysis_FoldChanges_NAsPerRow))
  
  # Filter the genes with too many NAs
  MetaAnalysis_FoldChanges_ForMeta <- MetaAnalysis_FoldChanges[MetaAnalysis_FoldChanges_NAsPerRow < CutOffForNAs,]
  MetaAnalysis_SV_ForMeta <- MetaAnalysis_SV[MetaAnalysis_FoldChanges_NAsPerRow < CutOffForNAs,]
  
  # Print the structure of the filtered FC
  print("MetaAnalysis_FoldChanges_ForMeta:")
  print(str(MetaAnalysis_FoldChanges_ForMeta))
  
  # Print the structure of the filtered SV
  print("MetaAnalysis_SV_ForMeta:")
  print(str(MetaAnalysis_SV_ForMeta))
  
  # Create a matrix with 6 columns filled with NAs to store the meta-analysis results
  metaOutput <- matrix(NA, nrow(MetaAnalysis_FoldChanges_ForMeta), 6)
  
  # Loop through each gene to perform meta-analysis
  for(i in c(1:nrow(MetaAnalysis_FoldChanges_ForMeta))){
    
    # Extract the Log2FC and SV value for the current gene in numeric format
    # Remove the annotation columns prior to extraction
    fc <- as.numeric(MetaAnalysis_FoldChanges_ForMeta[i, -c(1)])
    sv <- as.numeric(MetaAnalysis_SV_ForMeta[i, -c(1)])
    
    # Perform meta-analysis using random-effect model that treat Log2FC across 
    # studies as random effects
    
    # Set the flag as FALSE 
    # This flag is used to determine if the current iteration should be skipped
    # due to an error
    skip_to_next <- FALSE
    
    # The "tryCatch" function will execute the code within "{}" block. If an error
    # occurs, the code in the "error" block is executed
    tryCatch({
      # Perform meta-analysis that treat Log2FC across studies as random effects
      TempMeta <- rma(fc, sv)
      # Store estimated Log2FC
      metaOutput[i,1] <- TempMeta$b
      # Store standard error of estimate
      metaOutput[i,2] <- TempMeta$se
      # Store p-value
      metaOutput[i,3] <- TempMeta$pval
      # Store lower bound of the confidence interval
      metaOutput[i,4] <- TempMeta$ci.lb
      # Store the upper bound of the confidence interval
      metaOutput[i,5] <- TempMeta$ci.ub
      # Store the number of comparisons with available data
      metaOutput[i,6] <- NumberOfComparisons-sum(is.na(fc))
    },
      # If an error occurs during the meta-analysis, the "error" function sets
      # "skip_to_next" to TRUE
      error = function(e){skip_to_next <<- TRUE})
    
    # If "skip_to_next" is TRUE, the "next" statement skips the current iteration
    # and move to the next gene 
    if(skip_to_next) next
    
    # Remove temporary variables
    rm(fc, sv)
  } 
  
  # Name the columns in the output
  colnames(metaOutput) <- c("Log2FC_estimate", 
                            "SE", 
                            "pval", 
                            "CI_lb", 
                            "CI_ub", 
                            "Number_Of_Comparisons")
  
  # Assign the human entrez ID as row names of the output 
  row.names(metaOutput) <- MetaAnalysis_FoldChanges_ForMeta[,1]
  
  # Print the structure of the output
  print("metaOutput:")
  print(str(metaOutput))
  
  # Print the top of the output 
  print("Top of metaOutput:")
  print(head(metaOutput))
  
  # Print the bottom of the output 
  print("Bottom of metaOutput:")
  print(tail(metaOutput))
  
  # Change the format of the output to dataframe for the final list
  metaOutput <- as.data.frame(metaOutput)
  
  # Return the output and the annotation as separated lists
  return(list(metaOutput = metaOutput, 
              MetaAnalysis_Annotation = MetaAnalysis_FoldChanges_ForMeta[, c(1)],
              MetaAnalysis_FoldChanges_ForMeta = MetaAnalysis_FoldChanges_ForMeta,
              MetaAnalysis_SV_ForMeta = MetaAnalysis_SV_ForMeta))
}
```


```{r run_meta, cache = TRUE}
# Set up number of comparisons and cut off for NAs
# The number of NA = CutOffForNAs - 1
# Ex: 0 NA => CutOffForNA = 1
# Ex: 1 NA => CutOffForNA = 2

# There are 5 contrasts and we want genes that are available in all 5 contrasts
NumberOfComparisons = 5
CutOffForNAs = 1

# Function use 
# Meta-analysis with 0 NA
MetaAnalysis_Results_0NA <- suppressWarnings(
  RunBasicMetaAnalysis(NumberOfComparisons,
                       CutOffForNAs,
                       MetaAnalysis_FoldChanges,
                       MetaAnalysis_SV)
)

# Separate the meta-analysis output and annotation 
# 0 NA
metaOutput_0NA <- MetaAnalysis_Results_0NA[[1]]
MetaAnalysis_Annotation_0NA <- as.data.frame(MetaAnalysis_Results_0NA[[2]])
colnames(MetaAnalysis_Annotation_0NA) <- "Human_EntrezGene.ID"
MetaAnalysis_FoldChanges_ForMeta_0NA <- MetaAnalysis_Results_0NA[[3]]
MetaAnalysis_SV_ForMeta_0NA <- MetaAnalysis_Results_0NA[[4]]
```


### 14) Correction of p-value using Benjamini-Hochberg method

```{r func_FDR}
# Create a function to correct FDR and extract genes with certain threshold of FDR
# and Log2FC
FalseDiscoveryCorrection <- function(NumberOfNAs,
                                     metaOutput,
                                     MetaAnalysis_Annotation){
  
  # Calculate the FDR (q-value) for each p-value using the Benjamini-Hochberg method
  tempPvalAdjMeta <- mt.rawp2adjp(metaOutput[, 3], proc = c("BH"))
  
  # Re-order the FDR to match with the original order 
  metaPvalAdj <- tempPvalAdjMeta$adjp[order(tempPvalAdjMeta$index), ]
  
  # Add the FDR column to the meta-analysis output
  metaOutputFDR <- cbind(metaOutput, FDR = metaPvalAdj[, 2])
  
  # Rename the column to "FDR"
  colnames(metaOutputFDR)[7] <- "FDR"
  
  # Print the structure of meta-analysis output with FDR
  print("Meta-analysis output with FDR:")
  print(str(metaOutputFDR))
  
  # Add annotations to the output
  TempDF <- cbind(metaOutputFDR, MetaAnalysis_Annotation)
  
  # Save the annotated results to the meta-analysis output 
  metaOutputFDR_annotated <- TempDF
  
  # Export the annotated meta-analysis output into the working directory 
  # (remove the row names as entrez ID have been merged into the dataframe)
  write.csv(metaOutputFDR_annotated, 
            paste("metaOutputFDR_Annotated_", NumberOfNAs, "NA.csv", sep = ""), 
            row.names = FALSE)
  
  # Order the results by p-value 
  # The results are ordered by p-values because close p-values can result in the same
  # FDR due to the restriction of the algorithm (the bending of FDR)
  metaOutputFDR_OrderbyPval <- metaOutputFDR_annotated[order(metaOutputFDR_annotated$pval), ]
  
  # Filter the ordered results by Log2FC threshold at 2
  metaOutputFDR_OrderbyPval_Log2FC_2 <- metaOutputFDR_annotated %>%
    filter(abs(Log2FC_estimate) >= 2) %>%
    arrange(pval)
  
  # Filter the ordered results by Log2FC threshold at 1
  metaOutputFDR_OrderbyPval_Log2FC_1 <- metaOutputFDR_annotated %>%
    filter(abs(Log2FC_estimate) >= 1) %>%
    arrange(pval)
  
  # Filter the ordered results by Log2FC threshold at 0.5
  metaOutputFDR_OrderbyPval_Log2FC_0.5 <- metaOutputFDR_annotated %>%
    filter(abs(Log2FC_estimate) >= 0.5) %>%
    arrange(pval)
  
  # Export the ordered, annotated meta-analysis output into the working directory 
  # (remove the row names as entrez ID have been merged into the dataframe)
  write.csv(metaOutputFDR_OrderbyPval, 
            paste("metaOutputFDR_OrderedByPval_", NumberOfNAs, "NA.csv",sep = ""), 
            row.names = FALSE)
  
  # Export the ordered, annotated, filtered results at Log2FC of 2
  write.csv(metaOutputFDR_OrderbyPval_Log2FC_2, 
            paste("metaOutputFDR_OrderedByPval_Log2FC_2_", NumberOfNAs, "NA.csv",sep = ""), 
            row.names = FALSE)
  
  # Export the ordered, annotated, filtered results at Log2FC of 1
  write.csv(metaOutputFDR_OrderbyPval_Log2FC_1, 
            paste("metaOutputFDR_OrderedByPval_Log2FC_1_", NumberOfNAs, "NA.csv",sep = ""), 
            row.names = FALSE)
  
  # Export the ordered, annotated, filtered results at Log2FC of 0.5
  write.csv(metaOutputFDR_OrderbyPval_Log2FC_0.5, 
            paste("metaOutputFDR_OrderedByPval_Log2FC_0.5_", NumberOfNAs, "NA.csv",sep = ""), 
            row.names = FALSE)
  
  # Print genes with FDR < 0.1 
  print("# of genes that are statistically significant following loose FDR correction (FDR < 0.10):")
  print(sum(metaOutputFDR_annotated$FDR < 0.10, na.rm = TRUE))
  
  print("# of upregulated genes that are statistically significant following FDR < 0.10:")
  print(sum(metaOutputFDR_annotated$FDR < 0.10 & metaOutputFDR_annotated$Log2FC_estimate > 0, na.rm = TRUE))
  
  print("# of downregulated genes that are statistically significant following FDR < 0.10:")
  print(sum(metaOutputFDR_annotated$FDR < 0.10 & metaOutputFDR_annotated$Log2FC_estimate < 0, na.rm = TRUE))
  
  # Print genes with FDR < 0.05
  print("# of genes that are statistically significant following traditional FDR correction (FDR < 0.05):")
  print(sum(metaOutputFDR_annotated$FDR < 0.05, na.rm = TRUE))
  
  print("# of upregulated genes that are statistically significant following FDR < 0.05:")
  print(sum(metaOutputFDR_annotated$FDR < 0.05 & metaOutputFDR_annotated$Log2FC_estimate > 0, na.rm = TRUE))
  
  print("# of downregulated genes that are statistically significant following FDR < 0.05:")
  print(sum(metaOutputFDR_annotated$FDR < 0.05 & metaOutputFDR_annotated$Log2FC_estimate < 0, na.rm = TRUE))
  
  print("# of genes that are statistically significant following FDR < 0.05 and |Log2FC| ≥ 2:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_2$FDR < 0.05, na.rm = TRUE))
  
  print("# of upregulated genes that are statistically significant following FDR < 0.05 and |Log2FC| ≥ 2:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_2$FDR < 0.05 & metaOutputFDR_OrderbyPval_Log2FC_2$Log2FC_estimate > 0, na.rm = TRUE))
  
  print("# of downregulated genes that are statistically significant following FDR < 0.05 and |Log2FC| ≥ 2:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_2$FDR < 0.05 & metaOutputFDR_OrderbyPval_Log2FC_2$Log2FC_estimate < 0, na.rm = TRUE))
  
  print("# of genes that are statistically significant following FDR < 0.05 and |Log2FC| ≥ 1:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_1$FDR < 0.05, na.rm = TRUE))
  
  print("# of upregulated genes that are statistically significant following FDR < 0.05 and |Log2FC| ≥ 1:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_1$FDR < 0.05 & metaOutputFDR_OrderbyPval_Log2FC_1$Log2FC_estimate > 0, na.rm = TRUE))
  
  print("# of downregulated genes that are statistically significant following FDR < 0.05 and |Log2FC| ≥ 1:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_1$FDR < 0.05 & metaOutputFDR_OrderbyPval_Log2FC_1$Log2FC_estimate < 0, na.rm = TRUE))
  
  print("# of genes that are statistically significant following FDR < 0.05 and |Log2FC| ≥ 0.5:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_0.5$FDR < 0.05, na.rm = TRUE))
  
  print("# of upregulated genes that are statistically significant following FDR < 0.05 and |Log2FC| ≥ 0.5:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_0.5$FDR < 0.05 & metaOutputFDR_OrderbyPval_Log2FC_0.5$Log2FC_estimate > 0, na.rm = TRUE))
  
  print("# of downregulated genes that are statistically significant following FDR < 0.05 and |Log2FC| ≥ 0.5:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_0.5$FDR < 0.05 & metaOutputFDR_OrderbyPval_Log2FC_0.5$Log2FC_estimate < 0, na.rm = TRUE))
  
  # Print top results
  print("Top 20 results ordered by p-values:")
  print(head(metaOutputFDR_OrderbyPval$Human_EntrezGene.ID, 20))
  
  # Print top results with |Log2FC| ≥ 2
  print("Top 20 results ordered by p-values with |Log2FC| ≥ 2:")
  print(head(metaOutputFDR_OrderbyPval_Log2FC_1$Human_EntrezGene.ID, 20))
  
  # Print top results with |Log2FC| ≥ 1
  print("Top 20 results ordered by p-values with |Log2FC| ≥ 1:")
  print(head(metaOutputFDR_OrderbyPval_Log2FC_1$Human_EntrezGene.ID, 20))
  
  # Print top results with |Log2FC| ≥ 0.5
  print("Top 20 results ordered by p-values with |Log2FC| ≥ 0.5:")
  print(head(metaOutputFDR_OrderbyPval_Log2FC_0.5$Human_EntrezGene.ID, 20))
  
  # Return the annotated output and ordered output with FDR 
  return(list(metaOutputFDR = metaOutputFDR,
              metaOutputFDR_annotated = metaOutputFDR_annotated,
              metaOutputFDR_OrderbyPval = metaOutputFDR_OrderbyPval,
              metaOutputFDR_OrderbyPval_Log2FC_2 = metaOutputFDR_OrderbyPval_Log2FC_2,
              metaOutputFDR_OrderbyPval_Log2FC_1 = metaOutputFDR_OrderbyPval_Log2FC_1,
              metaOutputFDR_OrderbyPval_Log2FC_0.5 = metaOutputFDR_OrderbyPval_Log2FC_0.5))
  
  # Remove temporary objects
  rm(tempPvalAdjMeta, metaPvalAdj)
}
```


```{r run_FDR, cache = TRUE}
# Function use 

# Meta-analysis with 0 NA 
metaOutputFDR_all_0NA <- FalseDiscoveryCorrection(0,
                                                 metaOutput_0NA,
                                                 MetaAnalysis_Annotation_0NA)

# Separate the FDR outputs into individual objects 

# Meta-analysis with FDR output only 
metaOutputFDR_0NA <- metaOutputFDR_all_0NA[[1]]

# Meta-analysis with FDR output with annotations
metaOutputFDR_Annotated_0NA <- metaOutputFDR_all_0NA[[2]]

# Meta-analysis with FDR output ordered by p-values 
metaOutputFDR_OrderByPval_0NA <- metaOutputFDR_all_0NA[[3]]

# Meta-analysis with FDR output ordered by p-values filtered by Log2FC at 2
metaOutputFDR_OrderbyPval_Log2FC_2_0NA <- metaOutputFDR_all_0NA[[4]]

# Meta-analysis with FDR output ordered by p-values filtered by Log2FC at 1
metaOutputFDR_OrderbyPval_Log2FC_1_0NA <- metaOutputFDR_all_0NA[[5]]

# Meta-analysis with FDR output ordered by p-values filtered by Log2FC at 0.5
metaOutputFDR_OrderbyPval_Log2FC_0.5_0NA <- metaOutputFDR_all_0NA[[6]]
```


### 15) Forest plots for statistically significant genes 

```{r check_range}
# Check the range of Log2FC values
hist(metaOutputFDR_0NA[, 1], breaks = 40) 
```


```{r func_forest_plot}
# Create a function to generate forest plot
MakeForestPlots <- function(metaOutputFDR_annotated, 
                            GeneEntrezID, 
                            MetaAnalysis_FoldChanges_ForMeta,
                            MetaAnalysis_SV_ForMeta){
  
  # Extract the row corresponding to the provided Gene Entrez ID
  gene_row <- metaOutputFDR_annotated[metaOutputFDR_annotated$Human_EntrezGene.ID == GeneEntrezID, ]
  
  # Check if the gene exists
  if (nrow(gene_row) == 0){
    stop(paste("No gene found for GeneEntrezID:", GeneEntrezID))
  }
  
  # Extract Log2FC and SV 
  fc <- as.numeric(MetaAnalysis_FoldChanges_ForMeta[MetaAnalysis_FoldChanges_ForMeta$Human_EntrezGene.ID == GeneEntrezID, -c(1)])
  sv <- as.numeric(MetaAnalysis_SV_ForMeta[MetaAnalysis_FoldChanges_ForMeta$Human_EntrezGene.ID == GeneEntrezID, -c(1)])
  
  # Create the filename for the output plot
  filename <- paste("ForestPlot_GeneEntrezID_", GeneEntrezID, ".png", sep = "")
  
  # Open a PNG device with specified resolution
  png(filename, height = 5, width = 8, units = "in", res = 300)
  
  # Create the forest plot
  forest.rma(rma(fc, sv), 
             slab = colnames(MetaAnalysis_FoldChanges_ForMeta)[-c(1)], 
             xlim = c(-10, 10), 
             cex = 0.65)
  
  # Add labels to the plot
  mtext(paste("GeneEntrezID:", GeneEntrezID, sep = ""), 
        line = -1.5, 
        cex = 1.5)
  
  # Close the PNG device
  dev.off()
}
```


```{r run_forest_plot, cache = TRUE}
# Function use 

# Top genes ordered by p-values with |Log2FC| ≥ 2

# "7020"
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "7020",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# "51373"
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "51373",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# "10549"
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "10549",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# "221830"
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "221830",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# "54838"
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "54838",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# "221895"
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "221895",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# "11097"
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "11097",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# "54543"
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "54543",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# "5230"
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "5230",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# "2535"
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "2535",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)
```


**Interpretation of Forest Plots**

**1. Study Labels (Left Side)**

- The labels on the left side of the plot indicate the individual contrasts included
in the meta-analysis.

**2. Effect Sizes and Confidence Intervals (Right side)**

- Each horizontal line represents the effect size (Log2FC) for a particular contrast
along with its confidence interval. The squares represent the point of estimate of 
the effect size for each contrast. The horizontal lines extending from the squares
are the confidence intervals for the effect size.

- The size of the squares represent the weight of each contrast in the meta-analysis,
with larger square indicating more weight.


**3. Overall Effect (Bottom)**

- The diamond shape at the bottom of the plot represents the overall effect size 
calculated from the meta-analysis (random-effects model).

- The width of the diamond represents the confidence interval for the overall effect
size.

**4. X-axis (Observed Outcome)**

- The x-axis shows the scale/range for the effect sizes (Log2FC).

- The vertical dash line at 0 indicate no effect. Effect sizes to the left of this 
line suggest a decrease, while those to the right suggest an increase.


### 16) Retrieval the function of statistically significant gene  

```{r func_extract_gene_function}
# Create a function to get gene function from NCBI using Entrez Gene ID
GetGeneFunctionByID <- function(NumberOfNAs, Log2FCThreshold, EntrezGeneList) {
  
  # Create an empty list to store the result 
  gene_info_list <- list()
  
  # Loop through each Entrez Gene ID 
  for(i in EntrezGeneList){

    # Print the message indicating which gene is being processed 
    print(paste("Processing Entrez Gene ID:", i, sep = ""))
        
    # Retrieve the gene summary using the Entrez Gene ID
    gene_summary <- tryCatch({
      entrez_summary(db = "gene", id = i)
    }, 
    
    # In case of error, print a warning and return NULL 
    error = function(e){
      warning(paste("Error in retrieving data for Entrez Gene ID:", i, sep = "", e$message))
      return(NULL)
    })
    
    # Check if the gene summary was successfully retrieved  
    if(!is.null(gene_summary)){
      # If the gene summaray is not NULL, extract relevant info
      gene_info_list[[i]] <- list(
        # ID
        Entrez_ID = gene_summary$uid,
        # Gene symbol
        Gene_symbol = gene_summary$name,
        # Full name of gene
        Gene_description = gene_summary$description,
        # Location on chromosome
        Chromosome = gene_summary$chromosome,
        # Detailed location
        Map_location = gene_summary$maplocation,
        # Scientific name of model
        Model_scientific_name = gene_summary$organism$scientificname,
        # Common name of model
        Model_common_name = gene_summary$organism$commonname,
        # Function of the gene
        Gene_function = gene_summary$summary
      )
    } else {
      # If the gene summary is NULL, return NA for all columns
      gene_info_list[[i]] <- list(
        Entrez_ID = i,
        Gene_symbol = NA,
        Gene_description = NA,
        Chromosome = NA,
        Map_location = NA,
        Model_scientific_name = NA,
        Model_common_name = NA,
        Gene_function = NA
      )
    }
    # Introduce a delay of 0.5 seconds between request to avoid hitting API rate limit
    Sys.sleep(0.5)
  }
  
  # Convert the final list into a dataframe
  gene_info_df <- do.call(rbind, lapply(gene_info_list, as.data.frame))
  rownames(gene_info_df) <- NULL
  
  # Export the dataframe of gene function into working directory
  write.csv(gene_info_df, 
            paste("Gene_function_Log2FC_", Log2FCThreshold, "_", NumberOfNAs, "NA.csv", sep = ""))
  
  # Return the dataframe of gene function
  return(gene_info_df)
}
```


```{r run_extract_gene_function, cache = TRUE, message = FALSE}
# Extract gene entrez ID for genes with FDR < 0.05 & |Log2FC| ≥ 1
EntrezGeneList_OrderbyPval_Log2FC_1_0NA <- metaOutputFDR_OrderbyPval_Log2FC_1_0NA %>%
  filter(FDR < 0.05) %>%
  pull(Human_EntrezGene.ID)

# Extract gene entrez ID for genes with FDR < 0.05 & |Log2FC| ≥ 2
EntrezGeneList_OrderbyPval_Log2FC_2_0NA <- metaOutputFDR_OrderbyPval_Log2FC_2_0NA %>%
  filter(FDR < 0.05) %>%
  pull(Human_EntrezGene.ID)

# Function use
GeneFunction_Log2FC_1_0NA <- GetGeneFunctionByID(0,
                                                 1,
                                                 EntrezGeneList_OrderbyPval_Log2FC_1_0NA)

GeneFunction_Log2FC_2_0NA <- GetGeneFunctionByID(0,
                                                 2,
                                                 EntrezGeneList_OrderbyPval_Log2FC_2_0NA)

# Check the structure of the output
str(GeneFunction_Log2FC_1_0NA)
str(GeneFunction_Log2FC_2_0NA)
```


### 17) Enrichment analysis (EA) with KEGG/GO/Reactome databases

The difference between Enrichment Analysis, GSEA, and fGSEA:

**1. Enrichment Analysis (EA)**

- *Definition:* Enrichment analysis refers to a collection of methods used to determine 
whether predefined gene sets (such as biological pathways or functional categories) 
are overrepresented in a list of genes of interest, often derived from differential 
expression studies.

- *Goal:* The goal is to identify if specific gene sets are significantly enriched 
in the gene list compared to a background set of genes. This can highlight biological 
processes or pathways that are impacted in the condition of interest.

- *Method:* Enrichment analysis typically involves comparing the gene list to a 
background gene set using various statistical tests. The most common methods include 
Fisher's exact test, hypergeometric test,... The analysis can be performed on a 
gene set level without requiring a pre-ranked list.

- *Flexibility:* This approach can be used with different types of gene set databases 
(e.g., KEGG, GO, Reactome). The choice of the background gene set can affect the 
results, and the method may not be sensitive to the ranking of genes.

**2. Gene Set Enrichment Analysis (GSEA)**

- *Definition:* GSEA is a computational method used to determine whether a predefined 
set of genes shows statistically significant differences between two biological 
states or conditions based on a ranked list of genes.

- *Goal:* The goal of GSEA is to identify whether specific gene sets are overrepresented 
or enriched in a ranked list of genes, which is derived from differential expression 
analysis. GSEA is particularly useful for analyzing genome-wide expression profiles 
to determine whether gene sets are preferentially located at the top or bottom of 
the ranked list.

- *Method:* 

  - **Step 1: Calculation of Enrichment Score (ES)** 
  
  GSEA calculates an enrichment score that reflects the degree to which a gene set 
  is overrepresented at the extremes (top or bottom) of the ranked list. The score 
  is derived from a running-sum statistic, which increases when encountering genes 
  in the set and decreases otherwise, with the magnitude of the increment based 
  on the gene’s correlation with the phenotype.
  
  - **Step 2: Estimation of Significance Level of ES** 
  
  Significance is estimated using permutation-based tests, where phenotype labels 
  are permuted to create a null distribution for the ES. The empirical p-value is 
  calculated based on this distribution.
  
  - **Step 3: Adjustment for Multiple Hypothesis Testing** 
  The method normalizes the ES for each gene set to yield a normalized enrichment 
  score (NES). The false discovery rate (FDR) is calculated to control the proportion 
  of false positives.
  
- *Sensitivity:* GSEA is sensitive to the choice of background gene set and requires 
careful selection to avoid misleading results. It uses the entire ranked list of 
genes and does not rely on arbitrary cut-offs due to its rank-based. However, this 
sometimes results in gene sets/pathways that end up showing the strongest enrichment
are driven by genes that would not necessarily meet the traditional FDR cut-off. 
These genes are normally referred to as **"leading genes"**.

- *Input:* GSEA requires a full, pre-ranked list of genes based on metrics such as 
p-values or Log2FC.

**3.Fast Gene Set Enrichment Analysis (fGSEA)**

- *Definition:* fGSEA is an adaptation of GSEA designed to provide faster and 
computationally efficient enrichment analysis using approximation techniques.

- *Goal:* The goal of fGSEA is to maintain the accuracy of GSEA while significantly 
reducing the computation time required for large datasets.

- *Method:* fGSEA employs fast approximation methods for calculating enrichment scores,
which simplifies the process 

- *Flexibility:* fGSEA is more robust to variations in the background gene set due to
its approximation techniques but can still benefit from a well-chosen background for 
accurate interpretation. The output of fGSEA are leading genes, which is similar to GSEA.

- *Input:* fGSEA requires a full, pre-ranked list of genes based on metrics such as 
p-values or Log2FC.


| Feature                | Enrichment Analysis       | GSEA                 | fGSEA                |
|------------------------|----------------------------|----------------------|----------------------|
| Requires ranked gene list | No                         | Yes                  | Yes                  |
| Statistical test       | Various (e.g., Fisher's exact, hypergeometric) | Permutation-based     | Approximation-based   |
| Computational efficiency | Fast                       | Slow                 | Fast                 |
| Sensitivity to background | Less sensitive            | Sensitive            | Less sensitive        |


Ref for Overview of GSEA: 
https://www.pnas.org/doi/full/10.1073/pnas.0506580102

Ref for enrichment analysis with GO database using `clusterProfiler`: https://yulab-smu.top/biomedical-knowledge-mining-book/clusterprofiler-go.html

Ref for enrichment analysis with KEGG database using `clusterProfiler`:
https://yulab-smu.top/biomedical-knowledge-mining-book/clusterprofiler-kegg.html

Ref for enrichment analysis with KEGG database using `clusterProfiler`:
https://yulab-smu.top/biomedical-knowledge-mining-book/reactomepa.html


```{r func_EA_KEGG_GO_Reactome}
# Create a function to perform EA on common databases, including KEGG, GO, and 
# Reactome
EAPerform_KEGG_GO_Reactome <- function(EntrezGeneList,
                                       metaOuput,
                                       pvalueCutOff,
                                       qvalueCutOff){
  
  # Perform EA with KEGG database 
  KEGG_EA_result <- enrichKEGG(gene = EntrezGeneList,
                               # Organism code for Homo sapiens
                               organism = "hsa",
                               # Address the background gene set (output of meta-analysis)
                               universe = metaOuput,
                               # p-value cut off
                               pvalueCutoff = pvalueCutOff,
                               # Choose the method for FDR of GSEA (Benjamini-Hochberg)
                               pAdjustMethod = "BH",
                               # FDR cut off
                               qvalueCutoff = qvalueCutOff)
  
  # Perform EA with GO database 
  GO_EA_result <- enrichGO(gene = EntrezGeneList,
                           # Select database for Homo sapiens
                           OrgDb = org.Hs.eg.db,
                           # Ontology for biological process
                           # Other ontologies include "MF" for Molecular Function
                           # and "CC" for Cellular Component 
                           ont = "BP", 
                           # Address the background gene set (output of meta-analysis)
                           universe = metaOuput,
                           # p-value cut off
                           pvalueCutoff = pvalueCutOff,
                           # Choose the method for FDR of GSEA (Benjamini-Hochberg)
                           pAdjustMethod = "BH",
                           # FDR cut off
                           qvalueCutoff = qvalueCutOff)
  
  # Perform EA with Reactome database 
  Reactome_EA_result <- enrichPathway(gene = EntrezGeneList,
                                      # Organism code for Homo sapiens
                                      organism = "human",
                                      # Address the background gene set (output of meta-analysis)
                                      universe = metaOuput,
                                      # p-value cut off
                                      pvalueCutoff = pvalueCutOff,
                                      # Choose the method for FDR of GSEA (Benjamini-Hochberg)
                                      pAdjustMethod = "BH",
                                      # FDR cut off
                                      qvalueCutoff = qvalueCutOff)
  
  # Return the list of results
  return(list(KEGG = KEGG_EA_result, 
              GO = GO_EA_result,
              Reactome = Reactome_EA_result))
}
```


```{r run_EA_KEGG_GO_Reactome, cache = TRUE}
# Function use
EntrezGeneList_metaOutputFDR_0NA <- as.character(metaOutputFDR_Annotated_0NA$Human_EntrezGene.ID)

EA_Log2FC_1_0NA <- EAPerform_KEGG_GO_Reactome(EntrezGeneList_OrderbyPval_Log2FC_1_0NA,
                                              EntrezGeneList_metaOutputFDR_0NA,
                                              0.05,
                                              0.05)

EA_Log2FC_2_0NA <- EAPerform_KEGG_GO_Reactome(EntrezGeneList_OrderbyPval_Log2FC_2_0NA,
                                              EntrezGeneList_metaOutputFDR_0NA,
                                              0.05,
                                              0.05)

```


```{r plot_GSEA_KEGG, cache = TRUE}
# Visualize the EA results with KEGG database 

# There is only 1 enriched pathway on KEGG at loose p-value < 0.1 and loose FDR < 0.1 
# with EA_Log2FC_1_0NA: HIF-1 signaling pathway (hsa04066)

# There is no enriched pathway on KEGG at loose p-value < 0.1 and loose FDR < 0.1 
# with EA_Log2FC_2_0NA

# There is no enriched pathway on KEGG at p-value < 0.05 and FDR < 0.05 with EA_Log2FC_1_0NA

# There is no enriched pathway on KEGG at p-value < 0.05 and FDR < 0.05 with EA_Log2FC_2_0NA

# Visualize individual enriched pathways

# Filter genes with FDR < 0.05 in genes of meta-analysis output with |Log2FC| ≥ 1
KEGG_metaOutputFDR_Log2FC_1_0NA_FDR_0.05 <- metaOutputFDR_OrderbyPval_Log2FC_1_0NA %>%
  filter(FDR < 0.05)

# Prepare the named vector
# Names = Mouse_EntrezGene.ID | Values  = Log2FC estimate 
KEGGgenedata_metaOutputFDR_Log2FC_1_0NA <- setNames(
  KEGG_metaOutputFDR_Log2FC_1_0NA_FDR_0.05$Log2FC_estimate,
  KEGG_metaOutputFDR_Log2FC_1_0NA_FDR_0.05$Human_EntrezGene.ID
)

# Generate pathway view for "hsa04066" with genes of FDR < 0.05 and |Log2FC| ≥ 1
hsa04066 <- pathview(gene.data = KEGGgenedata_metaOutputFDR_Log2FC_1_0NA,
                     pathway.id = "hsa04066",
                     species = "hsa",
                     limit = list(gene = c(min(KEGGgenedata_metaOutputFDR_Log2FC_1_0NA), 
                                           max(KEGGgenedata_metaOutputFDR_Log2FC_1_0NA)), 
                                  cpd = 1))

```


```{r plot_GSEA_GO, cache = TRUE}
# Visualize the EA results with GO database 

# There is no enriched pathway on GO at p-value < 0.05 and FDR < 0.05 with EA_Log2FC_1_0NA

# There are 2 enriched pathway on GO at p-value < 0.05 and FDR < 0.05 with EA_Log2FC_2_0NA:
# Negative regulation of neurogenesis (GO:0050768) and Negative regulation of nervous
# system development (GO:0051961)

# Visualize the results with directed acyclic graph

# png("EA_Log2FC_2_0NA_GO_Network.png", 8, 5, "in", res = 300)
goplot(EA_Log2FC_2_0NA$GO)
# dev.off()

# 2 pathways using barplot presentation for genes with FDR < 0.05 and with |Log2FC| ≥ 2

# png("EA_Log2FC_2_0NA_GO.png", 8, 5, "in", res = 300)
barplot(EA_Log2FC_2_0NA$GO, showCategory = 10, font.size = 7)
# dev.off()
```


```{r plot_GSEA_Reactome, cache = TRUE}
# There is no enriched pathway on Reactome at p-value < 0.05 and FDR < 0.05 with EA_Log2FC_1_0NA

# There is no enriched pathway on Reactome at p-value < 0.05 and FDR < 0.05 with EA_Log2FC_2_0NA
```


```{r export_GSEA, cache = TRUE}
# Transform the matched pathways results into dataframes and export into the working
# directory

EA_Log2FC_2_0NA_GO <- as.data.frame(EA_Log2FC_2_0NA$GO)
row.names(EA_Log2FC_2_0NA_GO) <- NULL
write.csv(EA_Log2FC_2_0NA_GO, "EA_Log2FC_2_0NA_GO.csv")
```


### 18) Fast Gene Set Enrichment Analysis (fGSEA) with Brain.GMT database [Need to fix]

The Brain.GMT database, developed by Hagenauer et al. (2024), is designed to improve 
the interpretation of brain-derived differential expression results, especially 
in studies focused on neuropsychiatric disorders. The Brain.GMT can be used within 
common pipelines (GSEA, limma, edgeR) to interpret results from 3 species of rat, 
mouse, human. The database includes 918 gene sets derived from various sources, 
each curated to be relevant to brain functions, brain cell types, co-expression networks, 
and regional gene expression signatures.

Gene sets included in the Brain.GMT:

**1. MSigDB Gene SetS**

- Curated Gene Sets: 158 gene sets related to the nervous system.

- Cell Type Signature Gene Sets: 211 gene sets related to the nervous system and blood.

**2. BrainInABlender**

- 39 gene sets related to cell type-enriched expression, particularly in the cortex.

**3. DropViz**

- 13 gene sets focused on hippocampal expression, and 12 gene sets for the nucleus accumbens.

**4. HippoSeq**

- 14 gene sets related to regional enriched expression in the hippocampus.

**5. Coexpression Analyses**

- 55 gene sets derived from coexpression networks in the hippocampus.

**6. Gene Weaver**

- 33 gene sets for the hippocampus and 6 gene sets for the nucleus accumbens related 
to stress, environmental enrichment, affective behavior, and mood disorder.

**7. Gemma**

- 29 gene sets derived from reanalysis pipelines focusing on stress, environmental 
enrichment, affective behavior, and mood disorder in the nucleus accumbens.

Ref for Brain.GMT: https://doi.org/10.1016/j.mex.2024.102788

Ref for orginal GSEA: https://doi.org/10.1073/pnas.0506580102

Although the Brain.GMT focuses on brain-related genes, the impact of viral infection
might involve specific pathways or immune responses that are not well-represented
in this database.

Use all of the meta-analysis output and ordered it by Log2FC values (pre-ranked lists)

```{r run_GSEA_BrainGMT, eval = FALSE}
# fGSEA uses the entirety of the gene list but need to pre-ranked with either p-values
# or Log2FC. For Brain.GMT, we use gene list pre-ranked by Log2FC. 

# Retrieve gene symbols and gene functions using Entrez Gene ID for fGSEA
# (This takes approximately 5 hours for 15952 genes so please import the "GeneFunction_metaOutputFDR_0NA" 
# csv file or load the RData file to save time)
GeneFunction_metaOutputFDR_0NA <- GetGeneFunctionByID(0,
                                                      0,
                                                      EntrezGeneList_metaOutputFDR_0NA)

# Export the gene symbols and gene functions into the working directory 
write.csv(GeneFunction_metaOutputFDR_0NA, "GeneFunction_metaOutputFDR_0NA.csv")

# Rename the "Entrez_ID" column to "Human_EntrezGene.ID"
colnames(GeneFunction_metaOutputFDR_0NA)[colnames(GeneFunction_metaOutputFDR_0NA) == "Entrez_ID"] <- "Human_EntrezGene.ID"

# Merge gene function data with meta-analysis output based on Human_EntrezGene.ID
BrainGMT_genesummary_metaOutputFDR_0NA <- left_join(metaOutputFDR_Annotated_0NA, 
                                                    GeneFunction_metaOutputFDR_0NA,
                                                    by = "Human_EntrezGene.ID")

# Convert gene symbols to normal text with the first letter capitalized
BrainGMT_genesummary_metaOutputFDR_0NA$Gene_symbol <- str_to_title(BrainGMT_genesummary_metaOutputFDR_0NA$Gene_symbol)


# Create a named vector from meta-analysis output
# Names = Human gene symbol | Values = Log2FC estimate
BrainGMTgenedata_metaOutputFDR_0NA <- setNames(
  BrainGMT_genesummary_metaOutputFDR_0NA$Log2FC_estimate,
  BrainGMT_genesummary_metaOutputFDR_0NA$Gene_symbol
)

# Remove genes with NA or duplicated names
BrainGMTgenedata_metaOutputFDR_0NA_cleaned <- BrainGMTgenedata_metaOutputFDR_0NA %>%
  # Convert to dataframe for easier manipulation
  enframe(name = "gene_name", value = "Log2FC_estimate") %>%
  # Remove rows with NA names
  filter(!is.na(gene_name)) %>%
  # Remove rows with finite Log2FC values 
  filter(is.finite(Log2FC_estimate)) %>%
  # Remove duplicated names, keeping the first instance
  distinct(gene_name, .keep_all = TRUE) %>%
  # Convert back to named vector
  deframe()

# Order the vector by Log2FC in ascending order
BrainGMTgenedata_metaOutputFDR_OrderedbyLog2FC_0NA <- BrainGMTgenedata_metaOutputFDR_0NA_cleaned[order(BrainGMTgenedata_metaOutputFDR_0NA_cleaned)]

# Import the Brain.GMT for the specific species of interest
# Ignore the warning about incomplete line 
BrainGMT_Human <- gmtPathways("BrainGMTv2_wGO_HumanOrthologs.gmt.txt")

# Perform fast fGSEA with Brain.GMT
fGSEA_0NA_BrainGMT <- fgseaSimple(BrainGMT_Human, 
                                  BrainGMTgenedata_metaOutputFDR_OrderedbyLog2FC_0NA,
                                  # Number of permutations for the GSEA
                                  nperm = 10000,
                                  # Minimum size of gene sets to consider
                                  minSize = 10,
                                  # Maximum size of gene sets to consider 
                                  maxSize = 1000)

# Converts the list of leading edge genes (genes contributing to enrichment) in 
# the fGSEA results to a comma-separated string
fGSEA_0NA_BrainGMT$leadingEdge <- vapply(fGSEA_0NA_BrainGMT$leadingEdge, 
                                         paste, 
                                         collapse= ",", 
                                         character(1L))

# Order the fGSEA results based on adjusted p-values and count the number of leading 
# edges in each pathways
fGSEA_0NA_BrainGMT <- fGSEA_0NA_BrainGMT %>%
  arrange(padj) %>%
  mutate(Num_leadingEdge = sapply(strsplit(leadingEdge, ","), length))

# Export the matched pathways into the working directory
write.csv(fGSEA_0NA_BrainGMT, "fGSEA_0NA_BrainGMT.csv")
```


**Interpretation of fGSEA**

**1. padj (Adjusted p-value)**

- *Definition:* This is the p-value adjusted for multiple comparisons for the False 
Discovery Rate (FDR) using the family-wise error rate method. It controls for the 
proportion of false positives among the significant results. 

- *Explanation:* A low padj value (e.g., < 0.05) indicates that the enrichment of 
a gene set is statistically significant after correction for multiple testing, 
reducing the likelihood of false positives.

**2. ES (Enrichment Score)**

- *Definition:* The Enrichment Score (ES) represents the degree to which a gene set 
is overrepresented at the top or bottom of a ranked list of genes. It is calculated 
by walking down the list of pre-ranked genes and increasing a running-sum statistic 
when a gene in the gene set is encountered and decreasing it when a gene not in 
the gene set is encountered.

- *Explanation:*
  - A positive ES suggests that the gene set is enriched among genes that are upregulated 
  (i.e., genes at the top of the ranked list).
  - A negative ES indicates that the gene set is enriched among genes that are 
  downregulated (i.e., genes at the bottom of the ranked list).

**3. NES (Normalized Enrichment Score)**

- *Definition:* The Normalized Enrichment Score (NES) is the enrichment score (ES) 
that has been normalized across all gene sets to account for differences in gene 
set size. It allows for comparison between gene sets of different sizes.

- *Explanation:* 
  - NES adjusts the ES so that it can be compared across gene sets of different sizes:
    - Positive NES: Indicates the gene set is upregulated in your data.
    - Negative NES: Indicates the gene set is downregulated in your data.
    
**4. leadingEdge**

- *Definition:* The leading-edge subset is the subset of genes in the gene set 
that contribute most to the enrichment score. These are the genes that appear 
before the peak enrichment score is reached and thus drive the observed enrichment.

- *Explanation:* This variable contains the "core" genes responsible for the enrichment 
signal. Understanding which genes are in the leading edge can provide insights into 
which genes are most responsible for the phenotype of interest.

**5. nMoreExtreme**

- *Definition:* nMoreExtreme represents the number of permutations where the observed 
ES was more extreme (either higher or lower) than the ES obtained from random permutations 
of the gene set.

- *Explanation:* This variable helps estimate the empirical p-value for the observed ES. 
A lower nMoreExtreme value indicates that few random permutations achieved an ES as 
extreme as the observed one, suggesting that the observed enrichment is unlikely 
to be due to chance.

**6. Size**

- *Definition:* Size indicates the number of genes in the gene set that overlap 
with the pre-ranked list of genes used in the enrichment analysis.

- *Explanation:* This is the effective size of the gene set in the context of the 
analysis. Larger gene sets might have more opportunities to show enrichment, but 
smaller gene sets can also provide strong signals if their genes are strongly associated 
with the phenotype of interest.


